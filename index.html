<!DOCTYPE html>
<html>
	<head>
		<title>Hello World!aaa</title>
		<style>
		body {
			background-color: black;
		}
		</style>
	</head>
	<body>
		<canvas id="outputCanvas" width="512" height="424"></canvas>
		<script src="./shared/js/fps.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script>
		(function() {
			var util = require('util');
			var EventEmitter = require('events').EventEmitter;
			var ev = new EventEmitter;

			var depthWidth = 512, depthHeight = 424;
			var renderer, camera, scene, controls;
			var recordFlag = false;

			var fs = require('fs');
			// var wstream = fs.createWriteStream('depth.bin');
			// wstream.end();

			renderer = new THREE.WebGLRenderer( {
				canvas: document.getElementById('outputCanvas'),
				alpha: 1, antialias: true, clearColor: 0xffffff
			} );

			camera = new THREE.PerspectiveCamera( 40, renderer.domElement.width / renderer.domElement.height, 1, 10000 );
			camera.position.set( 0, 300, 3000 );
			controls = new THREE.TrackballControls( camera, renderer.domElement );
			scene = new THREE.Scene();

			function createGrid() {
				// ground box
				var geometry = new THREE.BoxGeometry( 500, 2, 500 );
				material = new THREE.MeshNormalMaterial();
				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, -1, 0 );
				scene.add( mesh );
				mesh = new THREE.GridHelper( 250, 10 );
				scene.add( mesh );

	      // axes
				var axis = new THREE.AxisHelper( 250 );
				scene.add( axis );
				renderer.render( scene, camera );

				var geometry = new THREE.BoxGeometry( 50, 20, 50 );
				var material = new THREE.MeshNormalMaterial();
				var box = new THREE.Mesh( geometry, material );
				scene.add( box );
      }

      createGrid();

			//create particles
			var particles = new THREE.Geometry();
			var colors = [];
			var numParticles = depthWidth * depthHeight;
			for(var i = 0; i < numParticles; i++) {
				var x = i % depthWidth - depthWidth * 0.5;
				var y = depthHeight - Math.floor(i / depthWidth);
				var vertex = new THREE.Vector3(x, y, Math.random());
				particles.vertices.push(vertex);
				colors[i] = new THREE.Color(0xffffff);
			}
			particles.colors = colors;
			var material = new THREE.PointCloudMaterial( { size: 3, vertexColors: THREE.VertexColors, transparent: true } );
			mesh = new THREE.PointCloud(particles, material);
			scene.add(mesh);

			window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function render() {
				renderer.render( scene, camera );
				controls.update();
				requestAnimationFrame(render);
			}

			onWindowResize();
			render();

			var processing = false;

			function recordData(depth) {
				if (recordFlag) {
					wstream.write(new Buffer(depth, 'ascii'));
				}
			}

			// setInterval( function() {
			//   if (data[nextFrame.index]) {
			//     nextFrame.sec = data[nextFrame.index].timestamp - startTime;
			//     if (nextFrame.sec == frame) {
			//       io.sockets.emit('bodyFrame', data[nextFrame.index]);
			//       nextFrame.index += 1; 
			//     } else if (data[nextFrame.index].timestamp == data[nextFrame.index - 1].timestamp) {
			//       nextFrame.index += 1; 
			//     }
			//     frame ++ ;
			//   } else {
			//     frame = 0;
			//     nextFrame = {index: 0, sec: 0};
			//   }
			// }, 1) 
			
			function depthDraw(data) {
				var depthBuffer = data;
				// var depthColorBuffer = frame.depthColor.buffer;
				if(processing) {
					return;
				}
				processing = true;
				var nDepthMinReliableDistance = 500;
				var nDepthMaxDistance = 4500;
				var mapDepthToByte = nDepthMaxDistance / 256;
				var j = 0, k = 0;

				for(var i = 0; i < depthBuffer.length; i+=2) {
					var depth = (depthBuffer[i+1] << 8) + depthBuffer[i]; //get uint16 data from buffer
					if(depth <= nDepthMinReliableDistance || depth >= nDepthMaxDistance) depth = Number.MAX_VALUE; //push them far far away so we don't see them
					particles.vertices[j].z = (nDepthMaxDistance - depth) - 2000;
					// particles.colors[j].setRGB(depthColorBuffer[k] / 255, depthColorBuffer[k+1] / 255, depthColorBuffer[k+2] / 255);
					j++;
					k+= 4;
				}
				particles.verticesNeedUpdate = true;
				// particles.colorsNeedUpdate = true;
				processing = false;
			}
			

			var readable = fs.createReadStream('depth.bin');
			readable.setEncoding('ascii');
			var depth1Frame = 434176,
					fps	= 30,
					bufferSec = 5;
					frameCount = 0;
			var dataDepthBuffer = [];
			var dataDepth = [];

			ev.once('datadone', function () {
				setInterval( function () {
					depthDraw(dataDepth.slice(frameCount * depth1Frame, frameCount * depth1Frame + depth1Frame));
					frameCount += 1;
				}, 1000); 
			});


			// var readable = getReadableStreamSomehow();
			// readable.on('data', function(chunk) {
			//   console.log('got %d bytes of data', chunk.length);
			//   readable.pause();
			//   console.log('there will be no more data for 1 second');
			//   setTimeout(function() {
			//     console.log('now data will start flowing again');
			//     readable.resume();
			//   }, 1000);
			// })

			// ここはすべてのデータが回収できるまでループし続ける
			readable.on('data', function(chunk) {
				// console.log(chunk.length)	
				dataDepthBuffer += chunk;
			  if (dataDepthBuffer.length > depth1Frame * fps * bufferSec) {
			  	readable.pause();
			  	console.log("stop!")
			  	dataDepth = new Buffer(dataDepthBuffer)
			  	ev.emit('datadone');
			  }
			})


			/* UI controller */
			window.onload = function() {
				document.getElementById("startscan").addEventListener("click", function (e) {
					recordFlag = !recordFlag
					if(e.target.innerHTML == "start") {
						e.target.innerHTML = "stop"
					} else {
						e.target.innerHTML = "start"
					}
				});
			}

		})();
		</script>
		<button id="startscan">start</button>
	</body>
</html>
